# Chapter 1: Introduction

In the last few decades, several different electronic platforms have emerged to aid our everyday life. Today, there are two main categories for typical usage: desktop and mobile platforms, with many different operating systems to run applications on.

Due to their long history, desktop operating systems (Windows, macOS, and Linux) have mostly stabilized. Meanwhile, mobile platforms are more dynamic still. While Android and iOS are currently the two main operating systems, and some have come and gone (Symbian, Windows Phone), new ones are still in development like Google's elusive Fuchsia or Huawei's HarmonyOS).

***Kép platformokról***

On the other hand, web platform technologies have grown to the point where standalone applications can be developed with them. Starting as a way to share information with other users through images, texts, and hyperlinks, the capabilities of websites gradually grew, thanks to browser-side code execution with Javascript and the browsers providing a way to reach different native interfaces.

Having so many different environments, one key factor before developing an application is determining the platform or platforms of development. This is further complicated by the fact that in today's society, one user typically owns multiple devices running different platforms, where a seamless cross-platform experience is a must. For these reasons - among others, like cost-cutting - cross-platform development is a viable alternative to native development for each patform individually.

## Cross-platform development

Developing an application for multiple different platforms can be achieved in several ways:

- **Native**: Developing an application for every supported operating system with its native development framework. While performance-wise this is the best way and every platform-specific resource is available to us as-is, it also incurs high development costs due to little to no code sharing. In-depth testing must also be done for each platform individually.

- **Responsive website**: Since most modern web browsers are available for consumer devices, creating a responsive website can be a reasonable alternative to native development. Responsive websites can accomodate different screen sizes, making them accessible for both desktop and mobile users. Depending on the browser's supported features, web applications can query the device's geographical location, provide offline support and push notifications, record audio and video, or even manage Bluetooth connections, just to mention a few capabilities. (for a detailed list, see https://whatwebcando.today/). If a web application conforms to [certain requirements](https://web.dev/install-criteria/) set by the browser, it is considered to be a *Progressive Web Application (PWA)*. Such PWAs can be installed and seen as a standalone application for the user on Android, iOS and desktop.

- **Hybrid**: While browsers expose many useful interfaces for web sites, a number of features are still not available (or are in experimental stages), such as NFC access or shape detection. A platform-specific native application (or at least a part of it) is neccessary to access such features. To circumvent the need for a native application, an alternative is to package and ship our web application with a custom browser - that exposes these native interfaces - as a standalone application (similar to how [Java applications can be packaged with a JVM implementation into a single executable application](https://docs.oracle.com/javase/9/tools/javapackager.htm#JSWOR719)). [Electron](https://www.electronjs.org/) is a framework that does exactly this and it powers many applications on the market nowadays, including Facebook Messenger, Slack, Twitch and Discord on desktop platforms.

-  **Native cross-platform**: Frameworks such as [React Native](https://reactnative.dev/), [NativeScript](https://nativescript.org/) and [Xamarin Native](https://visualstudio.microsoft.com/xamarin/) provide tools to write applications using a single code base in one programming language, while also allowing the use of platform specific native UI components. Applications build this way may be executed with the help of some kind of virtual machine (like [Mono](https://www.mono-project.com/docs/about-mono/) for Xamarin), or may be compiled to native machine instructions.

Every approach comes with its advantages and disadvantages, which must be considered at the start of development to determine the best approach for a project.

## Flutter

Flutter is an open-source cross-platform development framework maintained and owned by Google. It is relatively new, as the first preview version was released in 2015, while the first production-ready stable version became available in 2018. The main goals of Flutter are the following:

- Compile native applications for mobile, web and desktop platforms from a single codebase.
- Provide fast development cycles with the help of stateful hot reload.
- Support native-looking UI components with extensive customizability.
- Native-like performance in applications (60Hz rendering).

Flutter supports the following platforms as of now:

- Android: Stable, since initial release
- iOS: Stable, since initial release
- Web: Beta, since 2019
- Desktop (Windows, macOS, Linux): Alpha, since 2019

The development team has chosen the Dart language to develop the framework, as well as writing applications with. Dart is also owned by Google. Starting out as a compiled language running on the Dart VM with the intent to replace JavaScript in web browsers, they failed to convince Chrome's development team (a browser also owned by Google) to include a Dart VM in their application, and so refocused their efforts into providing a JavaScript transpiling tool. While Google uses Dart for their own projects, it failed to gain wide-spread propularity, staying mainly as a niche language until Flutter was released.

Flutter is a hybrid cross-platform framework, where instead of a web site, we create our application with Dart. Native cross-platform frameworks usually run into the 'lowest common denominator' problem, wherein the same UI component of different platforms might have different properties, such as different animation styles, different shapes and different functionalities, and so the cross-platform library can only expose the common properties with ease. Also, subtle differences between native components and behaviours can easily break an app in obscure ways and debugging them also becomes harder due to the added communication layer.

To combat these, the Flutter team decided to stay away from native UI components. Instead, they have re-created every platform-specific UI component in Flutter. These components are rendered by the [Skia engine](https://skia.org/) on native canvases. This way, Flutter can support many platforms with less effort. The only requirements are 

- a way to draw pixels on the screen (which is usually available through a native Canvas component), 
- a way to handle raw user inputs (such as a touch screen or mouse events), 
- and a way to run machine code compiled from C++ (available on most platforms).

A Flutter application will generally run the same way on every supported platform, and the styling (UI and UX) is up to the developer. For example, an application created with Material Design in mind will look and feel the same on iOS (which is not necessarily a good thing, but more on that later).

To achive this, Flutter consist of 3 main parts:

- the framework, where the UI components and other application funcionalities are implemented,
- the engine running our application, 
- and the platform-specific embedder. 

The following figure gives an overview of Flutter's architecture.
 
 ***Kép Flutter felépítésről***

With most cross-platform frameworks, there is a tradeoff between fast compilation and the performance of an application created with it. To achive hot-reload (where changes in the source code can be almost instantly seen in the running application), frameworks only analyze the source code for correctness and do small processing tasks, which will be then run directly on the device. In turn, to be performant, the source code is compiled with optimizations enabled, which increases compilation time, but has runtime benefits.

With this in mind, Flutter provides two separate build processes:

- In *debug* mode, an analyzer is run to make sure that the source code is *syntactically correct*. The source files are packaged with the Dart VM. Starting the application will load the source from this package into the memory. While running, triggering a hot reload (usually by saving source code files) will replace these source files in the memory, changing the behaviour of the program. Restarting the application will load the original source files again. This allows fast development cycles at the cost of low performance.
- In *release* mode, Dart code is compiled into native machine instructions while also linking some runtime libraries (such as the garbage collector). While the compilation time is longer than in debug mode, the resulting applications will be smaller and faster. Running them on emulators is not officially supported (however, Android x86_64 emualtors seem to be working as of now).
- There is also *profile* mode, which is similar to *release*, with the exception of a few debugging utilites being enabled to benchmark the performance of the application.

## The Dart programming language

Dart is a modern, object-oriented, class based, statically typed (since 2.0), compiled, garbage collected language with a syntax somewhat similar to Java. Let's look at some examples to understand how Dart works. For every example, a [DartPad link](https://nullsafety.dartpad.dev/) is provided, which opens the sample code in the browser in a Dart environment.

> DartPad is a great way to try out Dart language features, and it can even be used for quick Dart and Flutter prototyping. However, it is deinitely not a full-featured IDE, altough it has code completion to help us.

### Hello World

[DartPad](https://nullsafety.dartpad.dev/ff11838f11913e246e720a888acce2f3)

```dart
void main() {
  print("Hello World!");
}
```

Like with many other languages, every Dart application starts by calling a globally defined `main` function. We can already see a few properties of the language here. `void` means that the function does not return a value, while the parenthesis after the function name indicate that the `main` function does not take any parameters. Optionally, we could declare a parameter with the type of a *list of strings* to accept command line parameters.
The first thing we, as developers will probably do is declaring variables. Since *Dart 2.0*, the Dart language is type-safe: static type checking and runtime checks are used to ensure that a variable's runtime type matches its static type. This is also referred to as [sound typing](https://dart.dev/guides/language/type-system#what-is-soundness). While types are mandatory for variables, type annotations are usually optional due to Dart having [type interference](https://en.wikipedia.org/wiki/Type_inference).

Since *Dart 2.10*, Dart also features [sound null safety](https://dart.dev/null-safety) - a feature some modern languages, like [Kotlin](https://kotlinlang.org/) was designed with from early on. Due to Dart's history, this is a big milestone for the language.

While sound null safety is still in beta with Flutter, we decided to include it in this course since it will be an important part of future Flutter applications. Like with Kotlin, types must be annotated to indicate whether they can contain a *null* value or not.
With this in mind, let's take a look at different variable declarations.

### Variable declaration

[DartPad](https://nullsafety.dartpad.dev/c09129d1a0fed7990d7d9b44d6b32728)

```dart
//Global variable
bool globalFlag = false;

void main(List<String> args) {
  //Declaration with initialization
  String myString = "My string";
  print("String interpolation: $myString");
 
  //Declaration without initialization
  String tempString;
  //print(tempString.length); //!ERROR! Non-null value not initialized
  if (globalFlag){
    tempString = "True";
  } else {
    tempString = "False";
  }
  print("String after initialization: $tempString");
  
  //Object initialization
  Duration myDuration = Duration();
  print(myDuration);
  
  String? myNullString;
  print("Null coalescing: ${myNullString ?? "Null variable!"}");
  //print(myNullString.length); !ERROR! Function call on nullable variable
  print("Null aware property access: ${myNullString?.length}");
 
  var myAutoVar = "Automatic type";
  
  final myFinalVariable = "Hello";
  final myOtherFinalVariable = myAutoVar;
  const myConstVariable = "World!";
  //const myOtherConstVariable = myAutoVar; //!ERROR! Const value must be initialized with a constant value
}
```
A variable can be declared globally, locally in a function, or as a property of a class, while the initialization can happen at declaration, or at a later point in case of local variables. If the variable is initialized as it is declared, the type can be inferred from the value, in which case the *var* keyword can be used instead of the type annotation.

Dart provides a number of built-in types, some of the most important being:

- *int*
- *double*
- *num*: a supertype of *int* and *double*
- *bool*
- *String*
- Collections, such as *List*, *Set*, and *Map* 

A *final* variable can only be set once at initialization. A *const* "variable" is a constant expression which will be evaluated at compilation time (thus such "variables" and objects are called *compile-time constants*). If a constant object is created the parameters in its constructor must also be constants. In this case, two calls to the constructor with the same parameters will 'return' the same object.


If a variable is not explicitly initialized before its first use, it will contain the *null* value by default. In this case, the variable must be declared as a nullable type, while non-nullable variables must be initialized before use.
In case we surely know that a variable will be initialized before its first use, we can create a non-nullable variable with the added keyword [`late`](https://dart.dev/null-safety#creating-variables) (similarly to Kotlin's [`lateinit`](https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables) to help the compliler understand our intentions better, as shown in the following example:

[DartPad](https://nullsafety.dartpad.dev/c09129d1a0fed7990d7d9b44d6b32728)
```dart
bool test1(){
  print("Test1 function");
  return true;
}

bool test2(){
  print("Test2 function");
  return true;
}

late int testVariable;

void main(List<String> args) {
  //print("Late variable without initilaization: $testVariable"); //!RUNTIME ERROR! LateInitializationError
  testVariable = 5;
  print("Late variable after initialization: $testVariable");
  
  bool flag1 = test1();
  late bool flag2 = test2();
  print("Flag1 value: $flag1");
  print("Flag2 value: $flag2");
}
```
Using a `late` variable before initialization will result in a `LateInitializationError` being thrown. Annotating a local variable with the `late` keyword will make it lazily initialized (meaning that the initialization will only happen the first time the value is read). Note that globally declared variables are inherently lazy-initialized whether they are `late` or not.

Two special types are `Null` and `dynamic`:

[DartPad](https://nullsafety.dartpad.dev/b71678b6d1b7d992b7ce7e77cf39c43e)

```dart
void main(){  
  //Null value
  int? nullInt;
  print("Null values");
  print(nullInt.runtimeType);
  print(nullInt.hashCode);
  print(nullInt.toString());
    
  //Dynamic type
  dynamic testDynamic;
  testDynamic = 5;
  print(testDynamic.runtimeType);
  testDynamic = "Hello Dynamic!";
  print(testDynamic.runtimeType);
  //testDynamic.gcd(3); //!ERROR!
}
```

`Null` is a special type, with the only instance of it being `null`. Because `null` is an object, it has the `runtimeType` and `hashCode` properties, and a `toString` function implementation, which we can use freely.

The `dynamic` declaration tells the compiler to skip type checks for the given variable. Because of this, a `dynamic` variable can contain any value, and any function can be called on it (essentially reverting Dart back to *dynamic typing*, like in JavaScript). Runtime type checks are still used. Assigning a dynamic variable to a statically typed variable will result in a runtime exception if the assignment is not possible.

### Functions

Beside variables, function declaration and usage are also important parts of modern programming languages. Dart's function declaration and calling syntax is basically the same as Java's. The following code sample contains every important aspect of functions in Dart:

[DartPad](https://nullsafety.dartpad.dev/d9062516ed12df8e715a0910dd464b76)
```dart
void mySimpleFunction(){
  print("Inside function.");
  return;
}

int calculateSomeValue(int a, int b) => a + b;

void namedParametersFunction({String? name, String? description}){
  print("$name: $description");
}

positinalParametersFunction(int a, [int? b]) => a + (b ?? 0);

lambdaParameterFunction (void Function (int a) lambda){
  lambda(10);
}

void main() {
  mySimpleFunction();
  print(calculateSomeValue(3,5));
  
  namedParametersFunction(name: "Dani");
  namedParametersFunction(description: "Hello", name: "Dani");
  
  print(positinalParametersFunction(3));
  print(positinalParametersFunction(3,4));
  
  void myLocalFunction(){
    print("Function inside function!");
    return;
  }
  myLocalFunction();
  
  var myLambdaExpression = (int a, int b) => print(a+b);
  myLambdaExpression(1,1);
  var myLambdaDetailedExpression = (){
    print("Inside lambda expression");
    return 1;
  };
  print(myLambdaDetailedExpression());
  print(myLambdaDetailedExpression.runtimeType);
  
  lambdaParameterFunction((int a){
    print(a);
  });
}
```
A function declaration usually starts with the definition of the type of the returned value. If the function doesn't return any value, *void* can be used, or the type declaration can be omitted. Additionally, we can use the [`Never`](https://dart.dev/null-safety/understanding-null-safety#never-for-unreachable-code) type as an indicator for a function that never returns normally, like it always throws an exception or runs an infinite loop (this is analogous to Swift's [`Never`](https://developer.apple.com/documentation/swift/never) and Koltin's [`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html) types). 
If the return type is non-nullable, a value must be returned from the function. If the return type is nullable, the `return` statement can be skipped, in which case the `null` value will be returned implicitly.

The type declaration is followed by the name and the input parameters of the function. Dart supports higher-order functions, meaning that the functions themselves can be used as values, and they can also be passed to other functions as parameters (think about function pointers in C, if you've never met higher order functions before, otherwise the concept is the same as in Kotlin, Swift, or even JavaScript). Because of this, functions have types too. The type declaration of such a function has the following format: 

`<return type> Function(<parameters>) <variableName>`

Dart has three different function parameter types:

 - **Required positional parameters**: These parameters must be passed to the function. The parameters are identified by the position in which they are passed in.
 - **Optional positional parameters**: These parameters are optional. They follow the required positional parameter(s) in the parameter list of a function. If a value is not provided, an optional compile-time constant can be used as a default value, otherwise `null` will be the default value. They can be declared between square brackets *[]*.
 - **Optional named parameters**: These parameters are also optional. They have to be passed to the function with the name of the parameter followed by the provided value. Because of this, the order of such parameters is irrelevant (much like Kotlin's [named arguments](https://kotlinlang.org/docs/reference/functions.html#named-arguments), or Swift's [argument labels](https://docs.swift.org/swift-book/LanguageGuide/Functions.html). If a value is not provided, an optional compile-time constant can be used as a default value, otherwise `null` will be the default value. They can be declared between curly brackets *{}*.

A verbose function body goes between brackets *{}* after the parameter list. If the function only consists of one statement, it can be shortened with the *=>* (expression body) syntax, in which case the `return` keyword is also omitted.

## Installing Flutter SDK
## Installing Flutter in Android Studio
## Installing Flutter in Visual Studio Code




### Control structures
[DartPad](https://dartpad.dev/02741c2e7f2f8592022a4fa27d609b05)
```dart
void main() {
  bool myFlag = true;
  if (myFlag){
    print("True");
  } else if (!myFlag) {
    print("False");
  } else {
    print("Null");
  }
  
  for (int i = 0; i < 4; i++){
    print(i);
  }
  
  for (var j = ""; j.length < 4; j += "a"){
    print(j);
  }
  
  var j = 0;
  while(j < 6){
    j++;
    if (j == 3)
      continue;
    print(j);
  }
  do{
    print("Do-while");
    break;
  } while(true);
  
  var myList = [3, 4, 7];
  for (var value in myList){
    print(value);
  }
  
  var mySwitchVariable = 'Hello';
  switch (mySwitchVariable) {
    case 'Hello':
      print("Első");
      break;
    case 'World':
      print("Második");
      break;
    case 'TEST':
      print("Minden más");
      break;
    default:
      print("Ismeretlen");
  }
  
  assert(mySwitchVariable != "Hello");
  
  String nullVariable;
  try{
    nullVariable.substring(0);
  } on NoSuchMethodError catch(e){
    print("Error caught!");
  } finally {
    print("Finally called!");
  }
}
```

### List, Map, Set

[DartPad](https://dartpad.dev/42ee8b89b2805ff1b8edac5991c87eeb)
```dart
void main() {
  var myList = List();
  myList.add(5);
  myList.add("Hello");
  myList.add(Duration());
  print(myList);
  print(myList[1]);
  
  var myTypedList = List<String>();
  myTypedList.add("Hello");
  myTypedList.add("World!");
  //myTypedList.add(3); !ERROR!
  
  var myAutomaticList = [
    "World!",
    5,
    null
  ];
  print(myAutomaticList.runtimeType);
  
  var myIntList = [3, 5, 6, 18, 2];
  print(myIntList.length);
  print(myIntList.firstWhere((it) => it.isEven));
  print(myIntList.where((it) => it.isEven));
  //myIntList = myIntList.where((it) => true); !ERROR!
  myIntList.where((it){
    print("Inside where with: $it");
    return it.isEven;
  }).map((it){
    print("Inside map with: $it");
    return it.toString();
  }).firstWhere((it){
    print("Inside firstWhere with: $it");
    return it.length > 1;
  });
  print(myIntList.indexOf(8));
  //FONTOS! A dupla pont jelentése
  print(myIntList..retainWhere((it) => it.isEven));
  print(myIntList..sort((e1, e2) => e1.compareTo(e2)));
  //print(myIntList[5]); !ERROR!
  
  var myMap = {
    "test1" : 2,
    "test2" : 3,
    null : 2
  };
  print(myMap.runtimeType);
  print(myMap.keys);
  print(myMap.values);
  print(myMap.entries);
  
  var mySet = {1, 4, 6, 5, 4, 2, 1, 3};
  print(mySet);
  mySet.add(6);
  print(mySet);
  print(mySet.difference({4, 6, 9}));
  print(mySet.union({4, 6, 9}));
  print(mySet.intersection({4, 6, 9}));
  
  var whatIsThis = {};
  print(whatIsThis.runtimeType);
}
```

### Listák létrehozása feltételes kifejezésekkel

[DartPad](https://dartpad.dev/d87cea912ab2be236a30702713ba26b4)

```dart
import 'dart:math';

int testFunction(){
  return 4;
}

void main() {
  var myFirstList = [3, 5, 9];
  var mySecondList = [1, 2, 4, 5];
  print(myFirstList + mySecondList);
  myFirstList.addAll(mySecondList);
  print(myFirstList);
  
  var itemFlag = true;
  var myDetailedList = [
    1,
    itemFlag ? 2 : 9,
    if (itemFlag)
      3,
    testFunction(),
    for(int j = 5; j < 6; j++)
      j,
    ...myFirstList,
    ...mySecondList.map((it) => it + 1),
    for (int j = 11; j < 13; j++)
      ...[
        j,
        j * 2,
      ],
    for (var item in mySecondList)
      (){
        for (int i = 0; i < 10; i++){
          if (item == pow(2, i))
            return 0;
        }
        return item;
      }(),
  ];
  print(myDetailedList);
  
  //var myGenerator = ...[3, 2, 1]; !ERROR!
}
```
### Osztályok
[DartPad](https://dartpad.dev/51a9b8cc3b6cd4b9e673490d894ee468)
```dart
class PointClass{
  double x;
  double y;
  
  PointClass(double x, double y){
    this.x = x;
    this.y = y;
  }
  
  @override
  String toString(){
    return "PointClass(x: $x, y: $y)";
  }
}

class ConstPointClass{
  final double x;
  final double y;
  
  const ConstPointClass(double x, double y) : this.x = x, this.y = y;
  
  @override
  String toString(){
    return "ConstPointClass(x: $x, y: $y)";
  }
}

class VectorClass{
  double x;
  double y;
  
  VectorClass(this.x, this.y);
  VectorClass.zero() : this(0, 0);
  
  static final List<VectorClass> _poolList = [];
  factory VectorClass.pooled(){
    if (_poolList.isNotEmpty){
      return _poolList.removeLast()
        ..x = 0
        ..y = 0;
    } else {
      return VectorClass.zero();
    }
  }
  void recycle(){
    _poolList.add(this);
  }
  
  
  @override
  String toString(){
    return "VectorClass(x: $x, y: $y)";
  }
  
  @override
  int get hashCode => x.hashCode ^ y.hashCode;
  
  @override
  operator ==(dynamic other) => other is VectorClass && other.x == x && other.y == y;
  
  operator +(VectorClass other) => VectorClass(x + other.x, y + other.y);
}

enum Colors{
  RED, BLUE, GREEN
}

abstract class Listenable{
  void addListener(void Function(dynamic));
  void notifyListeners();
}
class ListenableInt extends Listenable{
  int value;
  @override
  void addListener(void Function(dynamic) Function) {
    // TODO: implement addListener
  }

  @override
  void notifyListeners() {
    // TODO: implement notifyListeners
  }
}

extension SafeListGetter<T> on List<T>{
  T getOrNull(int index) => this != null && index < this.length ? this[index] : null;  
}

void main(){
  var point1 = PointClass(1, 2);
  var point2 = PointClass(1, 2);
  print(point1);
  print(point1 == point2);
  
  var constPoint1 = const ConstPointClass(1, 2);
  var constPoint2 = const ConstPointClass(1, 2);
  print(constPoint1);
  print(constPoint1 == constPoint2);
  
  var vector1 = VectorClass(1, 2);
  var vector2 = VectorClass(1, 2);
  print(vector1);
  print(vector1 == vector2);
  print(vector1 + vector2);
  vector1 += vector2;
  
  var color = Colors.BLUE;
  print(color.index);
  print(color);
  
  var messageHolder = MessageHolder("Hello World!");
  messageHolder.phoneMyMessage();
  
  var extendedMessageHolder = ExtendedMessageHolder("Hello", "Tuesday");
  extendedMessageHolder.phoneMyMessage();
  print(extendedMessageHolder.receiveMessage());
  
  List<int> myList;
  print(myList.getOrNull(4));
}
```
